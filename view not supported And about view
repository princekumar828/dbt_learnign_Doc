The underlying root cause is that Iceberg tables drop CHAR, converting them to VARCHAR, which avoids errors.
	‚Ä¢	Views, however, inherit the original CHAR(1) type and fail validation.



	Iceberg enforces a fixed set of supported data types (like int, long, boolean, string, date, timestamp, decimal, arrays, maps, structs)  Ôøº.
	‚Ä¢	Trying to create a table or view that references an unsupported type‚Äîsuch as tinyint, smallint, char, fixed(L), uuid, or certain timestamp formats‚Äîwill trigger a schema validation error, regardless of whether it‚Äôs a table or a view  Ôøº.
	‚Ä¢	Views don‚Äôt store data; they just wrap the SQL query against the table. If the table has invalid types, the view won‚Äôt even compile/query due to the underlying schema issue.



    
‚∏ª

‚ùÑÔ∏è What Is an Iceberg View?

An Iceberg view is a logical, virtual table definition on top of one or more Iceberg tables. Unlike physical tables, it does not store any data, only the SQL query logic that defines it  Ôøº.

‚∏ª

üì¶ What It Consists Of

Per the official Iceberg View Spec:
	‚Ä¢	view-uuid: Unique identifier
	‚Ä¢	format-version: View spec version(1)
	‚Ä¢	location: Base path for metadata
	‚Ä¢	schemas: List of supported schemas
	‚Ä¢	current-version-id + versions + version-log: Tracks view history with timestamps
	‚Ä¢	properties: Optional metadata like comments
	‚Ä¢	representations: Different SQL dialects (e.g., Trino, Spark) with fields such as SQL text and dialect info

With Project Nessie, these views and their versions are stored right alongside Iceberg tables, allowing transactional branching, rollback, and experimentation .

‚∏ª

üéØ Why Use Iceberg Views?

1. Cross-engine Portability

Views are engine-agnostic‚Äîdefined in the Iceberg catalog‚Äîso tools like Trino, Spark, Dremio, etc., can all recognize and query them  Ôøº.

2. Data Abstraction & Governance

Users see only curated logic‚Äîlike filtered or aggregated datasets. Good for encapsulating complex business rules and hiding PII or internal joins  Ôøº.

3. Centralized, Versioned Logic

Changes to view SQL are tracked historically, facilitating auditability and rollback  Ôøº.

4. No Storage Overhead

Views don‚Äôt incur additional storage cost since they‚Äôre query definitions, not data copies  Ôøº.

‚∏ª

üöÄ How It Helps Your Data Stack

Benefit	Description
Simplifies Access	End-users use view names instead of writing JOINs and filters.
Ensures Consistency	One source of truth for calculations across tools.
Supports Evolution	SQL logic can change over time with a rollback if needed.
Enables Governance	Restrict access via views‚Äîdrop sensitive columns in view logic.
Enhances Interoperability	All engines can understand the same view definitions.


‚∏ª

üß© Example JSON Metadata (Simplified)

{
  "view-uuid": "...",
  "format-version": 1,
  "schemas": [...],
  "current-version-id": 42,
  "versions": [{
    "version-id": 42,
    "timestamp-ms": 172XXXXXXXXX,
    "representations": [
      {"type": "sql", "dialect": "trino", "sql": "SELECT ..."}
    ]
  }],
  "version-log": [...],
  "properties": {"comment": "customer summary view"}
}

This metadata ensures the view is fully described and versioned  Ôøº.

‚∏ª

üõ†Ô∏è When to Use Them
	‚Ä¢	To encapsulate complex transformations or business logic.
	‚Ä¢	To standardize KPIs across teams and tools.
	‚Ä¢	To restrict or mask data in multi-tenant environments.
	‚Ä¢	To support versioned feature engineering in MLOps.

‚∏ª

‚ú® In Summary

Iceberg views are powerful, flexible, versioned logical layers over your data. They enhance abstraction, portability, governance, and consistency‚Äîwith no data duplication. When combined with project version control (like Nessie), they become invaluable tools in modern lakehouse architecture.

‚∏ª

Would you like guidance on how to create them using Spark/Trino, or how to manage them via the REST API (like listing or versioning views)?
